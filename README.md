> 本文希望读者玩过云顶之弈，不懂编程的可以直接拉到最下面去看结论，懂编程的希望你了解递归、分治、图、堆这些基本概念，并掌握Python或者Go语言。
代码已公开在github上:[https://github.com/weiziyoung/TFT](https://github.com/weiziyoung/TFT) ，转载请注明来源。

今天是11月11日，首先恭喜FPX一顿摧枯拉朽横扫G2， 拿下S赛冠军！证明了LPL是世界第一赛区，也让电竞作为一种赛事在这代人心中铭记。本届S赛结束，也就意味着，S8告一段落，S9即将上线。而云顶之弈作为今年刚出的新模式，在上周11月6日也发布了S2元素崛起版本，一时间各种打法也是层出不穷，小编我也是一名忠实的云顶之弈玩家，但目前还没有玩过S2版本，主要想把这篇文章先写好分享给想读的人。

其实早在今年暑假刚出这个新模式，大家都还不会玩，还在摸索各种阵容的时候，我就在思考一件事——如何通过编程的手段搜索到6人口、7人口、8人口甚至9人口时凑到的最多的羁绊？这种想法来源于一个惨痛的经历，就是我第一次玩的时候，大概只凑出来了一个3贵族2骑士羁绊，就草草第七名带走了...当时就觉得这个游戏太难了，这么多卡片怎么能全记住？除了英雄之外，还有装备合成也跟英雄联盟差的很远，但玩个两三局，大概就明白：

这个游戏想吃鸡有三个核心——**羁绊**、**英雄等级**、**装备**， 三个核心有两个占优势，基本可以达到前四，三个都占优势，就稳定吃鸡了。这里我们主要讨论的就是去搜索**羁绊**，从而在这个维度上不吃亏。而装备这块比较靠脸，所以不做讨论，英雄等级这块其实可以根据每张卡在每个阶段出现的概率来估算出来这个阵容成型的难易程度，但是在本片博客里不做讨论，这里只讨论一个问题，就是**羁绊**。

# 文章大纲
- 云顶之弈游戏简介
- 基本算法思路
- 准备实验数据
- 排列组合的原理和实现
- 用图降低搜索复杂度
- 是否可以利用剪枝进一步降低复杂度？
- 评估函数的设计和实现
- 最小堆维护Top 100阵容
- 分析与总结

# 云顶之弈游戏简介
一般读到这里的读者应该都玩过云顶之弈，但为了照顾有些只打匹配排位从不下棋的同学，这里还是简单介绍一下这个游戏机制。
![image.png](https://wzy-zone.oss-cn-shanghai.aliyuncs.com/article_images%2F0x37e60f05a6fa8aimage.png)

- 方框`1`所在的是小小英雄，就是召唤师啦，好看用的。
- 方框`2`是你目前的队伍，这个队伍可以由不同英雄组成，但是队伍规模取决于你等级的高低。
- 方框`3`是你候选区的英雄，放一些你暂时不想上场的英雄，当然这个区域大多数是用来合成英雄的，3个相同1星英雄可以合成成2星，3个相同2星英雄可以合成为3星。当然我们这里不讨论如何优化英雄等级的话题。
- 方框`4`是发牌员给你发的牌，还有你目前有多少钱，每回合发牌员会给你发5张牌，你需要用金币去购买，这里只需要记住一点，星级越高的英雄越难抽到，并且也越强。
- 方框`5`就是我们的核心——羁绊了，它是根据场上的英雄的种族和职业所确定的，比如目前场上小炮和男枪可以组成一个枪手的buff，这个Buff可以使得枪手在攻击时造成2个目标伤害，而劫的话自己是个忍者，所以可以组成一个忍者buff，它可以提升自己暴击几率和攻击速度。每个羁绊都有自己的效果，同时，羁绊也有自己的等级，比如当你只有2个枪手的时候，你的枪手能够同时造成2个敌人的伤害，而4个枪手的时候，你可以再攻击时同时造成3个目标的伤害；同时羁绊也有范围，有的羁绊只对单个人有效，比如双帝国、三贵族、单忍者，大多数羁绊对同种族的有效，比如狂野、枪手、剑士，少数羁绊对队伍里所有英雄都有效，比如骑士、法师。

具体的S1版本英雄羁绊图如下(有一些后期英雄没加上去，比如潘森、卡萨、海克斯):
![image.png](https://wzy-zone.oss-cn-shanghai.aliyuncs.com/article_images%2F0x37e611184d2ee6image.png)

总共是56只英雄，大多英雄拥有一个种族，一个职业，船长的职业既是剑士也是枪手，纳尔的种族既是约德尔人也是狂野。一般来说，这个游戏在七人口时阵容成型，这个阶段基本能看出谁胜谁负，所以我们的目的就是选7个英雄，组成羁绊上最强的阵容。

# 基本算法思路

就像之前所说的，我们的目的是在56个英雄里选n个英雄，然后从里面选出羁绊最强的前K个。这句话可以拆分为这三个问题:
1. 首先，如何让计算机去自动把所有组合的可能性一个不拉地遍历出来？不重复也不漏检？
2. 其次，给定一个阵容，如何去评判羁绊的强度？
3. 第三，怎么去保存前K个羁绊最强的结果？

对于第一个问题来说，很多编程语言都有combination的拓展库，方便程序员求出一个列表的元素所有的组合可能性。但是这个是个好的方案嘛？真的可行嘛？如果不可行，怎么去优化？

对于第二个问题来说，我们在评估一个东西，或者说量化一个东西的时候，应该采用哪些指标？羁绊多是不是意味着羁绊就强？如果不是的话，是否需要引入主观性的一些指标，比如单个羁绊对英雄的增益程度？另外这个羁绊好成型嘛？是不是容易在组建的半路上暴毙？这些都是需要注意的问题。

对于第三个问题来说，看起来很容易，但排序真的可行吗？由于我们搜索的结果多达几百万个的阵容组合，全部排序后再取前K个现实嘛？

# 准备实验数据
本次主要使用语言为Go，并且用Python做一些脚本辅助我们做一些分析，之所以采用Go来写核心代码，是因为这种上百万轮次的搜索，Go往往比Python能快出一个数量级，同时Go工程化之类的也做的更好一些，语法也不至于像C++和Java那样繁琐。

程序 = 算法 + 数据。数据是一切的基石，要实现我们这次的目标，我们至少需要拥有两个数据:英雄数据、羁绊数据。在国外英雄联盟官网上，我们可以找到这个页面:[TFT GAMEPLAY GUIDE](https://na.leagueoflegends.com/en/news/game-updates/gameplay/teamfight-tactics-gameplay-guide?utm_source=web&utm_medium=web&utm_campaign=tft-microsite-2019)，接下来只要用Python 的BeautifulSoup包吧页面解析出来就可以了，大概20行代码就可以搞定了，由于思路比较简单，这里就不放代码了，给个链接自己看：[python_scripts/scrape.py](https://github.com/weiziyoung/TFT/blob/master/python_scripts/scrape.py)。

如下所示，这里我们需要记录英雄的元数据包括:名字、头像、费用、种族和职业，总共56个英雄，这里不展示了。需要的自己去取:[data/champions.json](https://github.com/weiziyoung/TFT/blob/master/data/champions.json)
```json
{
    "name": "Varus",
    "avatar": "https://am-a.akamaihd.net/image?f=https://news-a.akamaihd.net/public/images/articles/2019/june/tftcompendium/Champions/Varus.png&resize=64:",
    "price": 2,
    "origin": ["demon"],
    "class": ["ranger"]
}
```

另外是羁绊数据，这个数据可以从英雄数据里面整理出来，同时也要我们自己手填一些数据，以**恶魔**为例:
```json
{
    "name": "demon",
    "bonus_num": [2,4,6],
    "scope": [2,2,2],
    "champions": [
    "Varus","Elise","Morgana","Evelynn",
    "Aatrox","Brand","Swain"]
}
```
恶魔羁绊需要在2只时触发，且在4,6时羁绊进阶，那`bonus_num`就是`[2,4,6]`，而恶魔羁绊无论多少级，都是只有同种族的受益，所以范围序号是`2`，具体范围序号含义我们定义如下
1. `1`代表只有一个英雄能吃到这个羁绊buff的效果，典型的比如3贵族、2帝国。
2. `2`代表持有该羁绊的能够吃到这个buff效果，大多数羁绊都属于这个效果，比如恶魔、冰川、狂野、变形者、刺客、枪手、剑士、4帝国等等。
3. `3`代表队伍全部都可以吃到这个buff，比如6贵族、骑士、法师这些。
4. `4`代表一个特殊的羁绊范围，就是护卫了，护卫是除了护卫本身，其周围的人都能吃到buff。

`champions`就是持有这个羁绊的所有英雄了，全部羁绊数据在这里:[data/traits.json](https://github.com/weiziyoung/TFT/blob/master/data/traits.json)。这就是我们现在所能拿到的所有客观数据，不掺杂任何拍脑袋给的主观权重。实际上在评估时，这种数据越多越好，主观性太强的指标例如英雄强度、羁绊强度这种，公说公有理，婆说婆有理，很难有客观的结论，尽量少引入到评价体系中。

# 排列组合的原理和实现
现在我们有所有英雄了，作为召唤师，我觉得很有必要把它们一字排开欣赏欣赏...毕竟S2就看不到他们的绝大多数了。
![image.png](https://wzy-zone.oss-cn-shanghai.aliyuncs.com/article_images%2F0x37e6ce133434acimage.png)
所以我们的任务就是从55个英雄里面挑出8个英雄，让他们的羁绊数量最多。所以这是一个排列组合里的组合问题，可以根据公式求出组合数量:
$$ C_{n}^{m}=\frac{n!}{m!(n-m)!} $$
其中`n`等于55，`m`等于8，也就是八人口时，需要搜索`231917400`个不重复的可能性。
## 如何实现组合呢
最经典的思路就是分治了，看个简单的问题，比如对`[a,b,c,d,e]`求个数为3的所有组合。那么，我们首先会先把`a`取出来，问题简化成了对`[b,c,d,e]`求个数为2的所有组合。其次，我们把`b`取出来，问题简化成了对`[c,d,e]`求个数为1的所有组合，这时候问题就简单了.示意图如下：
![image.png](https://wzy-zone.oss-cn-shanghai.aliyuncs.com/article_images%2F0x37e6d4b7680260image.png)
红框表示你现在已经选择的字母，红框下面的数字代表需要继续进行组合的元素，到三层结束。
Python实现代码，非常短小精干，需要仔细品味和研读，理解递归、分治的优雅:
```Python
def combine(data, step, selected_data, target_num):
    if len(selected_data) == target_num:   # 递归的结束条件:已选择的元素数量等于目标数量
        print(selected_data)
        return
    if step == len(data):               # 游标到头了还没找出来，就结束吧
        return
    selected_data.append(data[step])             # 选择当前元素把她加到已选择的队伍里
    combine(data, step + 1, selected_data, target_num)  # 将游标推进，进入递归去找下一层
    selected_data.pop()                         # 把选择过的元素踢出去
    combine(data, step + 1, selected_data, target_num) #在不选择刚才被踢出去的元素情况下继续递归
if __name__ == '__main__':
    data = ['a','b','c','d', 'e']
    combine(data, 0, [], 3)
```
理解了上面这个代码，换个变量名，加入evaluate函数，就可以用于搜索我们的全羁绊了。
```Python
def combine(champions, step ,combo, max_num):
    if len(combo) == max_num: # 如果队伍到了最大的人口，就进行评估
        evaluate(combo)
        return
    if step == len(combo):  
        return
    combo.append(champions[step]) # 把游标所指定的英雄加到队伍里面去
    combine(champions, step + 1, combo, max_num)  # 游标往前进，继续抓壮丁
    combo.pop()  # 把刚才指定的英雄踢出去
    combine(champions, step+1, combo, max_num)   # 再继续往前进抓壮丁

def evaluate(combo):
    # 这里写给定一个阵容，怎么去评估它的强度，应该返回一个数值，或者是多个维度的评分结构体。
    # 往后再议
    pass

def init_champions():
    # 这里从json里读数据，代码略
    pass

if __name__ == "__main__":
    champions = init_champions()  # 把英雄数据导入进去，每个英雄应该是个结构体，或者是个字典。
    combine(champions, 0, [], 7) 
```
跑了一下，自行感受一下Python🐌蜗牛一般的速度吧:
![image.png](https://wzy-zone.oss-cn-shanghai.aliyuncs.com/article_images%2F0x37e77878ffd19cimage.png)
平均每秒遍历36979个结点，搜索6人口的最优羁绊大约要花14分钟，作为一个堆效率有追求的程序员，怎么能够容忍这种事情出现？？
